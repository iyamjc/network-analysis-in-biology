s <- 0.0#
for(i in 1:1000){#
	s <- s + 0.0001#
}
s == 1
s <- 0.0#
for(i in 1:1000){#
	s <- s + 0.0001#
}#
s == 1
s
s <- 0.0#
for(i in 1:10000){#
	s <- s + 0.0001#
}#
s == 1
s
s == 1
s - 1
fx <- function(x){#
	return(2 * x)#
}
fx
fx(2)
fx(5)
fx(10)
q()
load(".RData")
library(leaflet)
leaflet() %>% #
    addTiles()
q()
load(".RData")
library(igraph)
d <- read.table("data/ecoli_ppi_Hu_etal_2009.txt")
d <- read.table("data/ecoli_ppi_Hu_etal_2009.txt")
d
g <- simplify(graph.data.frame(d,directed=F),remove.multiple=T,remove.loops=T)
g
clusters(g,"weak")
# 最大連結成分の取得#
cls <- clusters(g,"weak")#
g <- delete.vertices(g,subset(V(g),cls$membership!=which(cls$csize==max(cls$csize))[[1]]))
g
degree <- degree(g)
degree
eigen <- evcent(g)$vector
eigen
# 次数中心性（degree centrality）#
degree <- degree(g)#
# 固有ベクトル中心性（eigenvector centraliry）#
eigen <- evcent(g)$vector#
# PageRank#
page <- page.rank(g)$vector#
# 近接中心性（closeness centrality）#
closen <- closeness(g)#
# 媒介中心性（betweenness centrality）#
between <- betweenness(g)#
# サブグラフ中心性（betweenness centrality）#
subgraph <- subgraph.centrality(g)
page
## データフレームにまとめる#
nprop <- data.frame(V(g)$name,degree,eigen,page,closen,between,subgraph)#
names(nprop)[[1]] <- "gene"
nprop
nprop[1:5,]
ess <- read.table("data/ecoli_proteins_essentiality_Baba2006MSB.txt",header=T)
ess[1:5,]
nprop[1:5,]
d <- merge(ess,nprop,by="gene")
d[1:5,]
d <- d[d$essential!="u",]#
levels(d$essential)[[3]] <- NA
boxplot(log(d$degree)~d$essential,xlab="Essentiality",ylab="Degree")
ess_nprop <- d[d$essential=="E",]#
# 非必須タンパク質の中心性指標#
noness_nprop <- d[d$essential=="N",]#
#
# wilcoxon test#
cat("## 次数中心性（degree centrality）\n")#
cat("中央値　必須：",median(ess_nprop$degree),"非必須：",median(noness_nprop$degree),"\n")#
wilcox.test(ess_nprop$degree,noness_nprop$degree)
g <- as.undirected(read.graph("data/karate.GraphML",format="graphml"))
g
plot(g)
if(!is.null(get.edge.attribute(g,"weight"))) g <- delete_edge_attr(g, "weight")
## Topological overlap score matrixの計算#
# 隣接行列（Aij）を得る#
A_ij <- get.adjacency(g,sparse=F)#
# Jijの計算#
J_ij <- cocitation(g)#
# min(ki,kj)の計算#
deg <- degree(g)#
deg_mtx <- matrix(0,nrow=vcount(g),ncol=vcount(g))#
for(i in 1:vcount(g)){#
	for(j in 1:vcount(g)){#
		deg_mtx[i,j] <- min(deg[[i]],deg[[j]])#
	}#
}
overlap_mtx <- (J_ij + A_ij) / (deg_mtx + 1 - A_ij)#
diag(overlap_mtx) <- 1
overlap_mtx <- (J_ij + A_ij) / (deg_mtx + 1 - A_ij)#
diag(overlap_mtx) <- 1
dist <- as.dist(1 - overlap_mtx)
dist
# 群平均法に基づいて階層的クラスタリング#
res <- hclust(dist, method="average")#
# デンドログラムをプロット#
plot(res)
mem <- cutree(res, k=2)
mem
V(g)$color <- mem#
# ネットワークを描画。ノードの形が実際のメンバーシップに対応する。#
plot(g,vertex.size=10, vertex.label=V(g)$name, vertex.shape=c("circle","square")[V(g)$Faction])
library(rnetcarto)
data <- cluster_fast_greedy(g)
data
data$membership
plot()
dendPlot(data, main="貪欲アルゴリズム")
plot(data, g)
mtx <- get.adjacency(g, sparse=F)
mtx
res <- netcarto(mtx)#
# igraphの出力結果と一致するように出力を調整#
table <- as.data.frame(res[[1]])#
table$module <- table$module + 1#
row.names(table) <- table$name#
table <- table[V(g)$name,]#
data <- list(membership = table$module, modularity=c(res[[2]]))
table
plot(g, vertex.color=as.numeric(table$role), main="Functional Cartography", vertex.shape=c("circle","square","sphere","pie")[table$module])
library(linkcomm)
el <- get.edgelist(g)
el
el <- gsub(" ","_",el)
el
q()
